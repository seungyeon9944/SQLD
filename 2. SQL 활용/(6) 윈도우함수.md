### 윈도우 함수

**OVER** 키워드와 함께 사용, 역할에 따라 나눌 수 있음

### 1. 순위 함수

### `RANK`

1, 2, 2, 4, 5, 5, 7, …

```sql
SELECT ORDER_DT,
       COUNT(*),
       RANK() OVER(ORDER BY COUNT(*) DESC) AS RANK
  FROM STARBUCKS_ORDER
  GROUP BY ORDER_DT;
```

### `DENSE_RANK`

1, 2, 2, 3, 4, 4, 5, …

### `ROW_NUMBER`

1, 2, 3, 4, 5, 6, 7, …

---

### 2. 집계함수

### `SUM`

✏️ *OVER절에서 ORDER BY절에 명시해주면 **RANGE UNBOUNDED PRECEDING 구문이 없어도 누적합**  - 컬럼값이 **같은경우 하나의 그룹으로 묶어서** 누적합 **계산***

```sql
SELECT EMPLOYEE_ID,
       NAME,
       SALARY,
       SUM(SALARY) OVER(ORDER BY SALARY) AS SUM1, # 누적합
       SUM(SALARY) OVER(ORDER VY SALARY
                        RANGE UNBOUNDED PRECEDING) AS SUM2 # 누적합
FROM EMPLOYEES;
```

### ⭐`MAX` / `MIN` / `AVG` / `COUNT`

최대 최소 평균 데이터개수 ..

- `RANGE BETWEEN **UNBOUNDED PRECEDING** AND CURRENT ROW` : 처음 ~ 현재 행까지
- `ROWS BETWEEN CURRENT ROW AND **UNBOUNDED FOLLOWING**` : 현재 행 ~ 끝까지 (내림차순에서 마지막 데이터를 출력해주려면 UNBOUNDED FOLLOWING 반드시 명시해주어야)
- `RANGE BETWEEN 10 PRECEDING AND CURRENT ROW` : 현재 행의 값보다 10만큼 적은 행 ~ 현재 행까지

✏️ 오답노트

```sql
SELECT DEPARTMENT_ID,
       NAME,
       SALARY,
       COUNT(*) OVER(PARTITION BY DEPARTMENT_ID # 부서별로
                     ORDER BY SALARY DESC # 급여 높은 사원부터 정렬한다음
                     RANGE BETWEEN 2000 PRECEDING 
                     AND CURRENT ROW) AS SALARY2
                     # 부서의 맨왼쪽 끝 행부터 현재 행까지 비교하여 
                     # 본인의 급여보다 2000 이하로 차이나는 건수 카운트
FROM EMPLOYEES;
```

✏️ 오답노트 : *윈도우 절에 ORDER BY가 쓰였는데 범위가 안적혀있으면 **RANGE UNBOUNDED PRECEDING이 디폴트**임 !!*

```sql
SELECT DEPARTMENT_ID,
       NAME,
       SALARY,
       HIRE_DATE,
       MIN(SALARY) OVER(PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE) AS MIN_SAL
       # DEPARTMENT_ID별로 **첫행부터 현재 행까지의** SALARY의 **최솟값** 표시
  FROM EMPLOYEES;
```

---

### 3. 행 순서 함수

### `FIRST_VALUE`  / `LAST_VALUE`

파티션별 가장 선두에 위치한 데이터 / 파티션별 가장 끝에 위치한 데이터

### `LAG (컬럼 [,특정 수])`

*✏️ 파티션별로 특정 수만큼 **앞선 데이터** 구함.* default는 1

### `LEAD (컬럼 [,특정 수])`

*✏️ 파티션별로 특정 수만큼 **뒤에 있는 데이터** 구함.* default는 1

---

### 4. 비율 함수

### `RATIO_TO_REPORT`

파티션별 합계에서 차지하는 비율

### ⭐`PERCENT_RANK`

해당 파티션의 **맨 위** 끝을 **0**, **맨 아래** 끝을 **1**로 놓고 **현재 행이 위치**하는 백분위 순위 값

= **(k-1) / (n-1)**

```sql
SELECT STUDENT_NAME,
       SUBJECT,
       SCORE,
       RANK() OVER(ORDER BY SCORE) AS RANK,
       COUNT(*) OVER() AS COUNT,
       (RANK() OVER(ORDER BY SCORE)-1)/(COUNT(*) OVER()-1) AS "PR",
       PERCENT_RANK() OVER(ORDER BY SCORE) AS PERCENT_RANK
FROM SQLD;
```

### ⭐`CUMIE_DIST`

해당 파티션에서의 **누적 백분율**. 0~1 사이 값

### ⭐`NTILE`

주어진 수만큼 **행들을 n등분**한 후 현재 행에 해당하는 등급

n등분했을 때 나머지 남으면 **맨 앞의 그룹부터 하나씩 더 채워짐**

```sql
SELECT STUDENT_NAME,
       SCORE,
       NTILE(1) OVER(PARTITION BY SUBJECT ORDER BY SCORE DESC) AS NTILE1,
       NTILE(3) OVER(PARTITION BY SUBJECT ORDER BY SCORE DESC) AS NTILE3
  FROM SQLD;
```